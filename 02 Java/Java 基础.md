# 基础概念
## Java语言具有哪些特点？
1. Java为纯==面向对象==的语言。它能够直接反应现实生活中的对象。
2. ==一次编译，处处运行==。java利用Java虚拟机运行字节码，无论是在Windows、Linux还是MacOS等其它平台对Java程序进行编译，编译后的程序可在其它平台运行。
3. Java为==解释型语言==，编译器把Java代码编译成平台无关的中间代码，然后在JVM上解释运行，具有很好的可移植性。
4. Java提供了很多内置类库。如对多线程支持，对网络通信支持，最重要的一点是==提供了垃圾回收器==。
5. Java具有较好的安全性和健壮性。Java提供了异常处理和垃圾回收机制，去除了C++中难以理解的指针特性。
6. Java语言提供了对Web应用开发的支持。
## 面向对象的三大特性？
1. 继承：对象的一个新类可以从现有的类中派生，派生类可以从它的基类那继承方法和实例变量，且派生类可以修改或新增新的方法使之更适合特殊的需求。
2. 封装：将客观事物抽象成类，每个类可以把自身数据和方法只让可信的类或对象操作，对不可信的进行信息隐藏。
3. 多态：允许不同类的对象对同一消息作出响应。不同对象调用相同方法即使参数也相同，最终表现行为是不一样的。
## 字节序定义以及Java属于哪种字节序？
字节序是指多字节数据在计算机内存中存储或网络传输时个字节的存储顺序。
通常由小端和大端两组方式。
1. 小端:   低位字节存放在内存的低地址端，高位字节存放在内存的高地址端。
2. 大端：高位字节存放在内存的低地址端，低位字节存放在内存的高地址端。
Java语言的字节序是==大端==。

## JDK与JRE有什么区别？
1. JDK：Java开发工具包（ Java Development Kit ），提供了Java的开发环境和运行环境。
2. JRE：Java运行环境( Java Runtime Environment )，提供了Java运行所需的环境。
==JDK包含了JRE==。如果只运行Java程序，安装JRE即可。要编写Java程序需安装JDK。

# 基础语法
## 判等运算符 == 与equals的区别？
== 比较的是引用，equals比较的是内容。
1. 如果变量是基础数据类型，== 用于比较其对应值是否相等。如果变量指向的是对象, == 用于比较两个对象是否指向同一块存储空间。
2. equals是Object类提供的方法之一，每个Java类都继承自Object类，所以每个对象都具有equals这个方法。Object类中定义的equals方法内部是直接调用 == 比较对象的。但通过覆盖的方法可以让它不是比较引用而是比较数据内容。

## 对equals()和hashCode()的理解?
-   **为什么在重写 equals 方法的时候需要重写 hashCode 方法**?
因为有强制的规范指定需要同时重写 hashcode 与 equals 是方法，许多容器类，如 HashMap、HashSet 都依赖于 hashcode 与 equals 的规定。
-   **有没有可能两个不相等的对象有相同的 hashcode**?
有可能，两个不相等的对象可能会有相同的 hashcode 值，这就是为什么在 hashmap 中会有冲突。相等 hashcode 值的规定只是说如果两个对象相等，必须有相同的hashcode 值，但是没有关于不相等对象的任何规定。
-   **两个相同的对象会有不同的 hash code 吗**?
不能，根据 hash code 的规定，这是不可能的。


## java移位运算符
java中有三种移位运算符
-   `<<` :左移运算符,`x << 1`,相当于x乘以2(不溢出的情况下),低位补0
-   `>>` :带符号右移,`x >> 1`,相当于x除以2,正数高位补0,负数高位补1
-   `>>>` :无符号右移,忽略符号位,空位都以0补齐

## final、finally和finalize的区别是什么？
1. final用于声明属性、方法和类，分别表示属性不可变、方法不可覆盖、类不可继承。
2. finally作为异常处理的一部分，只能在try/catch语句中使用，finally附带一个语句块用来表示这个语句最终一定被执行，经常被用在需要释放资源的情况下。
3. finalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的finalize()方法。当垃圾回收器准备好释放对象占用空间时，首先会调用finalize()方法，并在下一次垃圾回收动作发生时真正回收对象占用的内存。

# 数据类型
##  简述Java基本数据类型
byte: 占用1个字节，取值范围-128 ~ 127
short: 占用2个字节，取值范围-215 ~ 215-1
int：占用4个字节，取值范围-231 ~ 231-1
long：占用8个字节
float：占用4个字节
double：占用8个字节
char: 占用2个字节
boolean：占用大小根据实现虚拟机不同有所差异
## 拆箱装箱原理
对于 Java 基本数据类型，均对应一个包装类。
装箱就是自动将基本数据类型转换为包装器类型，如int->Integer 
拆箱就是自动将包装器类型转换为基本数据类型，如Integer->int 

装箱过程是通过调用包装器的 valueOf 方法实现的，将原值赋给对应类。
拆箱过程是通过调用包装器的 intValue / doubleValue 等方法实现，返回基本的数据类型。

## Java中一维数组和二维数组的声明方式？
一维数组的声明方式：
1. type arrayName[]
2. type[] arrayName
二维数组的声明方式：
1. type arrayName[][]
2. type[][] arrayName
3. type[] arrayName[]
其中type为基本数据类型或类，arrayName为数组名字

# 面向对象


## 构造方法、成员变量初始化、静态成员变量的初始化顺序？
先后顺序：静态成员变量、成员变量、构造方法。
详细的先后顺序：父类静态变量、父类静态代码块、子类静态变量、子类静态代码块、父类非静态变量、父类非静态代码块、父类构造函数、子类非静态变量、子类非静态代码块、子类构造函数。

## Java代码块执行顺序
1. 父类静态代码块（只执行一次）
2. 子类静态代码块（只执行一次）
3. 父类构造代码块
4. 父类构造函数
5. 子类构造代码块
6. 子类构造函数
7. 普通代码块

## 简述Java访问修饰符
default : 默认访问修饰符，在同一包内可见
private : 在同一类内可见，不能修饰类
protected : 对同一包内的类和所有子类可见，不能修饰类
public : 对所有类可见
## Java语言中关键字static的作用是什么？
static的主要作用有两个：
1. 为某种特定数据类型或对象分配与创建对象个数无关的单一的存储空间。
2. 使得某个方法或属性与类而不是对象关联在一起，即在不创建对象的情况下可通过类直接调用方法或使用类的属性。
具体而言static又可分为4种使用方式：
1. 修饰成员变量。用static关键字修饰的静态变量在内存中只有一个副本。只要静态变量所在的类被加载，这个静态变量就会被分配空间，可以使用''类.静态变量''和''对象.静态变量''的方法使用。
2. 修饰成员方法。static修饰的方法无需创建对象就可以被调用。static方法中不能使用this和super关键字，不能调用非static方法，只能访问所属类的静态成员变量和静态成员方法。
3. 修饰代码块。JVM在加载类的时候会执行static代码块。static代码块常用于初始化静态变量。static代码块只会被执行一次。
4. 修饰内部类。static内部类可以不依赖外部类实例对象而被实例化。静态内部类不能与外部类有相同的名字，不能访问普通成员变量，只能访问外部类中的静态成员和静态成员方法。

## 简述Java中Class对象
java中对象可以分为实例对象和Class对象，每一个类都有一个Class对象，其包含了与该类有关的信息。
获取Class对象的方法：
Class.forName(“类的全限定名”)
实例对象.getClass()
类名.class

## this() & super()在构造方法中的区别？
-   调用super()必须写在子类构造方法的第一行, 否则编译不通过
-   super从子类调用父类构造, this在同一类中调用其他构造均需要放在第一行
-   尽管可以用this调用一个构造器, 却不能调用2个
-   this和super不能出现在同一个构造器中, 否则编译不通过
-   this()、super()都指的对象,不可以在static环境中使用
-   本质this指向本对象的指针。super是一个关键字

##  简述java的多态
Java多态可以分为编译时多态和运行时多态。
编译时多态主要指方法的重载，即通过参数列表的不同来区分不同的方法。
运行时多态主要指继承父类和实现接口时，可使用父类引用指向子类对象。
运行时多态的实现：主要依靠方法表，方法表中最先存放的是Object类的方法，接下来是该类的父类的
方法，最后是该类本身的方法。如果子类改写了父类的方法，那么子类和父类的那些同名方法共享一个
方法表项，都被认作是父类的方法。因此可以实现运行时多态。

## 简述抽象类与接口的区别
抽象类：体现的是 is-a 的关系，如对于 man is a person，就可以将 person 定义为抽象类。
接口：体现的是can的关系。是作为模板实现的。如设置接口fly，plane类和bird类均可实现该接口。
一个类只能继承一个抽象类，但可以实现多个接口。

## 接口和抽象类的相同点和区别？
相同点:
1.  ==都不能被实例化==。
2. 接口的实现类或抽象类的子类需实现接口或抽象类中相应的方法才能被实例化。
不同点：
1. 接口只能有方法定义，不能有方法的实现，而抽象类可以有方法的定义与实现。
2. 实现接口的关键字为implements,继承抽象类的关键字为extends。一个类可以实现多个接口，只能继承一个抽象类。
3. 当子类和父类之间存在逻辑上的层次结构，推荐使用抽象类，有利于功能的累积。当功能不需要，希望支持差别较大的两个或更多对象间的特定交互行为，推荐使用接口。使用接口能降低软件系统的耦合度，便于日后维护或添加删除方法。

## 为什么Java语言不支持多重继承？
为了==避免二义性==，使程序的结构能够更加清晰。
假设Java语言支持多重继承，类C继承自类A和类B,如果类A和B都有自定义的成员方法f(),那么当代码中调用类C的f()会产生二义性。
Java语言通过实现多个接口间接支持多重继承，接口由于只包含方法定义，不能有方法的实现，类C继承接口A与接口B时即使它们都有方法f(),也不能直接调用方法，需实现具体的f()方法才能调用，不会产生二义性。
多重继承会使类型转换、构造方法的调用顺序变得复杂，会影响到性能。

## Java提供的多态机制？
Java提供了两种用于多态的机制，分别是重载与覆盖。
1. 重载：重载是指同一个类中有多个同名的方法，但这些方法有不同的参数，在编译期间就可以确定调用哪个方法。
2. 覆盖：覆盖是指派生类重写基类的方法，使用基类指向其子类的实例对象，或接口的引用变量指向其实现类的实例对象，在程序调用的运行期根据引用变量所指的具体实例对象调用正在运行的那个对象的方法，即需要到运行期才能确定调用哪个方法。

## 重载与覆盖的区别？
1.  覆盖是父类与子类之间的关系，是垂直关系；重载是同一类中方法之间的关系，是水平关系。
2. 覆盖只能由一个方法或一对方法产生关系；重载是多个方法之间的关系。
3. 覆盖要求参数列表相同；重载要求参数列表不同。
4. 覆盖中，调用方法体是根据对象的类型来决定的，而重载是根据调用时实参表与形参表来对应选择方法体。
5. 重载方法可以改变返回值的类型，覆盖方法不能改变返回值的类型。

## 重载与重写的区别
重写即子类重写父类的方法，方法对应的形参和返回值类型都不能变。
重载即在一个类中，方法名相同，参数类型或数量不同。

# 常见类
## 简述Object类常用方法
1. hashCode：通过对象计算出的散列码。用于map型或equals方法。需要保证同一个对象多次调用该方法，总返回相同的整型值。
2. equals：判断两个对象是否一致。需保证equals方法相同对应的对象hashCode也相同。
3. toString: 用字符串表示该对象
4. clone:深拷贝一个对象

## 简述内部类及其作用
成员内部类：作为成员对象的内部类。可以访问private及以上外部类的属性和方法。外部类想要访
问内部类属性或方法时，必须要创建一个内部类对象，然后通过该对象访问内部类的属性或方法。
外部类也可访问private修饰的内部类属性。
局部内部类：存在于方法中的内部类。访问权限类似局部变量，只能访问外部类的final变量。
匿名内部类：只能使用一次，没有类名，只能访问外部类的final变量。
静态内部类：类似类的静态成员变量。

## String和StringBuffer有什么区别？
String用于字符串操作，属于不可变类。String对象一旦被创建，其值将不能被改变。
而StringBuffer是可变类，当对象创建后，仍然可以对其值进行修改。
## 简述String / StringBuffer与StringBuilder
String类采用利用final修饰的字符数组进行字符串保存，因此不可变。如果对String类型对象修改，需要
新建对象，将老字符和新增加的字符一并存进去。
StringBuilder，采用无final修饰的字符数组进行保存，因此可变。但线程不安全。
StringBuffer，采用无final修饰的字符数组进行保存，可理解为实现线程安全的StringBuilder。
## 为什么要把String设计为不变量？
1. 节省空间：字符串常量存储在JVM的字符串池中可以被用户共享。
2. 提高效率:String会被不同线程共享，是线程安全的。在涉及多线程操作中不需要同步操作。
3. 安全：String常被用于用户名、密码、文件名等使用，由于其不可变，可避免黑客行为对其恶意修改。
## compator和compatable的区别
Comparable 是一个接口，用于对象内部的比较方式，该接口需要实现的方法是：
```Java
public interface Comparable<T> {
	public int compareTo(T o);
	}
```
Comapator 也是一个接口，该接口有个compare方法，该接口需要实现的方法是：
```java
public interface Comparator<T> {
	int compare(T o1, T o2);
	}
```
除该方法外，comparator还可以实现其他方法。
## 动态代理实现方式
1. 利用JDK反射机制，实现代理接口
2. 利用CGLib，对指定类生成子类，进行代理。

## 简述OOM（out of memory）
当JVM分配内存不够会抛出out of memory异常

## 简述StackOverFlowError
调用栈深度超过限制产生的异常。
一般会在递归调用时出现。

# 泛型
## 简述泛型
泛型是为了解决代码复用的问题，让多种数据类型能够执行相同的代码
泛型，即“参数化类型”，解决不确定对象具体类型的问题。在编译阶段有效。
在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型在类中称为泛型类、接口中称为泛型接口和方法中称为泛型方法。
## 简述泛型擦除
其实Java的泛型是一种伪泛型，它仅仅是语法上支持泛型，但是Java编译器生成的字节码是不包涵泛型信息的，在编译阶段会进行所谓的“**类型擦除**”（Type Erasure），将所有的泛型表示（尖括号中的内容）都替换为具体的类型（其对应的原生态类型），就像完全没有泛型一样。
类型擦除会造成多态的冲突，而JVM解决方法就是桥接方法。
## 如何理解基本类型不能作为泛型类型？
> 比如，我们没有`ArrayList<int>`，只有`ArrayList<Integer>`, 为何？

因为当类型擦除后，ArrayList的原始类型变为Object，但是Object类型不能存储int值，只能引用Integer的值。
另外需要注意，我们能够使用`list.add(1)`是因为Java基础类型的自动装箱拆箱操作。

# 注解
## 简述注解
Java 注解用于为 Java 代码提供元数据。作为元数据，注解不直接影响你的代码执行，但也有一些类型的注解实际上可以用于这一目的。
其可以用于提供信息给编译器，在编译阶段时给软件提供信息进行相关的处理，在运行时处理写相应代码，做对应操作。
## 简述元注解
元注解可以理解为注解的注解，即在注解中使用，实现想要的功能。其具体分为：
@Retention: 表示注解存在阶段是保留在源码，还是在字节码（类加载）或者运行期（JVM中运行）。
@Target：表示注解作用的范围。
@Documented：将注解中的元素包含到 Javadoc 中去。
@Inherited：一个被@Inherited注解了的注解修饰了一个父类，如果他的子类没有被其他注解修饰，则它的子类也继承了父类的注解。
@Repeatable：被这个元注解修饰的注解可以同时作用一个对象多次，但是每次作用注解又可以代表不同的含义。
# 异常
## 简述Java异常的分类
Java异常分为Error（程序无法处理的错误），和Exception（程序本身可以处理的异常）。这两个类均继承Throwable。
Error常见的有StackOverFlowError,OutOfMemoryError等等。
Exception可分为运行时异常和非运行时异常。对于运行时异常，可以利用try catch的方式进行处理，也可以不处理。对于非运行时异常，必须处理，不处理的话程序无法通过编译。
**Throwable** 是 Java 语言中所有错误与异常的超类。
-   **Error** 类及其子类：程序中无法处理的错误，表示运行应用程序中出现了严重的错误。
-   **Exception** 程序本身可以捕获并且可以处理的异常。Exception 这种异常又分为两类：运行时异常和编译时异常。
![Pasted image 20220728220247](../assets/Pasted%20image%2020220728220247.png)
-   **运行时异常**

都是RuntimeException类及其子类异常，如NullPointerException(空指针异常)、IndexOutOfBoundsException(下标越界异常)等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。

运行时异常的特点是Java编译器不会检查它，也就是说，当程序中可能出现这类异常，即使没有用try-catch语句捕获它，也没有用throws子句声明抛出它，也会编译通过。

-   **非运行时异常** （编译异常）

是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。

## 简述throw与throws的区别
throw一般是用在方法体的内部，由开发者定义当程序语句出现问题后主动抛出一个异常。
throws一般用于方法声明上，代表该方法可能会抛出的异常列表。

## 出现在Java程序中的finally代码块是否一定会执行？
当遇到下面情况不会执行。
1. 当程序在进入try语句块之前就出现异常时会直接结束。
2. 当程序在try块中强制退出时，如使用System.exit(0)，也不会执行finally块中的代码。
其它情况下，在 try / catch / finally语句执行的时候，try块先执行，当有异常发生，catch和finally进行处理后程序就结束了，当没有异常发生，在执行完finally中的代码后，后面代码会继续执行。
值得注意的是，当try/catch语句块中有return时，finally语句块中的代码会在return之前执行。如果try / catch / finally块中都有return语句，finally块中的return语句会覆盖try/catch模块中的return语句。
# 反射
## Java反射机制是什么？
Java反射机制是指在程序的运行过程中可以构造任意一个类的对象、获取任意一个类的成员变量和成员方法、获取任意一个对象所属的类信息、调用任意一个对象的属性和方法。
反射机制使得Java具有动态获取程序信息和动态调用对象方法的能力。可以通过以下类调用反射API。
Class类：可获得类属性方法
Field类：获得类的成员变量
Method类：获取类的方法信息
Construct类：获取类的构造方法等信息

## java反射原理
Java会在编译期装载所有的类，并将其元信息保存至Class类对象中。
因此可以设计x.class/x.getClass()/Class.forName()等方法获取Class对象。所以在反射调用Field / Method / Constructor对象时，可根据Class类对象进行进一步操作。
## 简述 Java 的反射机制及其应用场景

# IO

## 序列化是什么？
序列化是一种将对象转换成字节序列的过程，用于解决在对对象流进行读写操作时所引发的问题。
序列化可以将对象的状态写在流里进行网络传输，或者保存到文件、数据库等系统里，并在需要的时候把该流读取出来重新构造成一个相同的对象。

## 简述Java序列化与反序列化的实现
序列化：将java对象转化为字节序列，由此可以通过网络对象进行传输。
反序列化：将字节序列转化为java对象。
具体实现：实现Serializable接口，或实现Externalizable接口中的writeExternal()与readExternal()方法。


## 简述 BIO, NIO, AIO 的区别
BIO (Blocking I/O)
**BIO 属于同步阻塞 IO 模型** 。
同步阻塞 IO 模型中，应用程序发起 read 调用后，会一直阻塞，直到内核把数据拷贝到用户空间。

### AIO (Asynchronous I/O)

AIO 也就是 NIO 2。Java 7 中引入了 NIO 的改进版 NIO 2,它是异步 IO 模型。

异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。